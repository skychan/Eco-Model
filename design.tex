% !TEX root = Eco-Model.tex
\section{Design of the ecosystem} % (fold)
\label{sec:design_of_the_ecosystem}
\subsection{Preliminaries} % (fold)
\label{sub:preliminaries}
With the cloud manufacturing platform operating, demander publish orders while provider provide resources, then they communicate with each other, arrange the resources to perform tasks that decomposed by orders. Finally, product is produced and delivered to the demander. Most recent researchers like Wu et al.\cite{Wu2013} describe this operation procedure in cloud manufacturing as a tri-group user model that contains:\begin{inparaenum}[1)]
\item Users/Customers,
\item Application providers and
\item Physical resource providers.
\end{inparaenum}
Inspired by the such model, we design the original mode shown in \autoref{fig:originmode} as the basis for the operating of the platform.
\begin{figure}[htbp]
    \centering
    \resizebox{0.9\textwidth}{!}{\input{figures/origin_mode}}
    \caption{Original mode}
    \label{fig:originmode}
\end{figure}
In this mode, individual in each group execute activities that interact with others with object flow(full lines) and information flow(dashed lines). As the start of manufacturing activities procedure, the demander publish orders that can be depicted by a so-called activity-on-node(AON) network where the nodes represent the tasks and the arcs the precedence relations. Each task needs to performed with pre-determined configuration of resources, hence, after the response and assign procedure, the selected resource cannot start to process the task until all of other selected resources by this task are ready, we call this procedure as resource cooperating and what each resource actually process is the task part. Finally product will be delivered to demander after the process and assembly of these parts, then the review of the product will change the rank value of the selected resource owners. Task part is a virtual segmentation of one task, it just like if we run one program in cloud computing platform, we actually use some quota of provider A's DB and some quota of provider B's CPU, we can consider them as task parts. A little more about the cooperation procedure, this produce is necessary because the capacity limit of resources and task part should be processed simultaneously to make sure that the task is being processed with required resource capacities. We call the task part is active when being processed, semi-active when resource is waiting for synchronization, inactive when the part is just assigned to the job list.

\subsubsection{Assumptions} % (fold)
\label{ssub:assumptions_nomenclature}
To scope our research, we make some assumptions as follows:
\begin{compactitem}
\item Each single task should be assembled by part according to the pre-determined resources configuration, and these parts should be processed simultaneously;
\item Since the cooperation, the quality of product is determined by the worst quality part of produced by selected resource;
\item Resource are renewable that the available capacity will be return when the process produce finished;
\item Resource quality comply normal distribution with given mean and standard deviation by provider when registered;
\item Cooperate and process produce cannot be interrupted;
\item Provider can only schedule task part that in inactive status. 
\end{compactitem}
These assumptions are suitable for original mode, in other extension mode, some of the assumptions will be modified.

\begin{table}[htbp]
  \scriptsize
\begin{tabularx}{\textwidth}{|lX|}
    \hline
    \multicolumn{2}{|l|}{\multirow{2}[0]{*}{\textbf{Nomencalture}}} \\
    \multicolumn{2}{|l|}{} \\
	$o_i$ & Order that come with demander \\
	$\mathcal{T}_i$ & Task set of $o_i$ \\
	$t_{ij}$ & Task belongs to $o_i$, $t_{ij}\in\mathcal{T}_i$ \\
	$p_{ij}$ & Process duration of $t_{ij}$\\
	$\gamma_{ij}$ & Expect quality of product after the finish of $t_{ij}$\\
	$r_i$ & Release time of $o_i$\\
	$f_{ij}$ & Actual finish time of $t_{ij}$ \\
	$f_{i}$ & Finish time of $o_i$\\
	$\mathcal{P}_{ij}$ & The set of predecessor of $t_{ij}$\\
	$mr_k$ & Resource that come with provider \\
	$\delta_k$ & Product quality produced via resource $mr_k$ \\
	$C_{k,\tau}$ & Capacity of $mr_k$ at time $\tau$\\
	$A_{k,\tau}$ & Available capacity of $mr_k$ at time $\tau$\\
	$\mathcal{L}_{k,\tau}$ & The list of inactive job queue of $mr_k$ at $\tau$ with sequence\\
	$\mathcal{H}_{k,\tau}$ & The list of semi-active job of $mr_k$ at $\tau$ \\
	$\mathcal{G}_{k,\tau}$ & The set of active job of $mr_k$ at $\tau$ \\ 
	$f^{(s)}_j$ & Ideal finish time of $t_j$ in $\mathcal{L}^{(s)}_{k,\tau_0}$ for schedule . \\
	$re_j$ & Remaining process time of $t_j$ in $\mathcal{G}_{k,\tau_0}$ for schedule . \\
	$\mathcal{A}$ & Resource type set \\
	$\mathcal{A}_{ij}$ & Resource type subset required by $t_{ij}$, $\mathcal{A}_{ij}\subset\mathcal{A}$\\
	$q_{\alpha,ij}$ & Required amount of resource with type $\alpha$ by $t_{ij}$\\
	$sc_l$ & Service-call generated by provider\\
	$p_l$ & Process duration of $sc_l$\\
	$r_l$ & Release time of $sc_l$\\
	$\mathcal{P}_{l}$ & The set of predecessor of $sc_{l}$\\
	$\mathcal{A}_l$ & Resource type subset required by $sc_l$ or provided by $ms_l$ , $\mathcal{A}_l\subset\mathcal{A}$\\
	$ms_l$ & Service that generated after the finish of $sc_l$\\
	$\Delta_l$ & Product quality produced via service $ms_l$\\
	$\bm{mr}_l$ & Resource member set of $ms_l$\\
	$\bm{q}_l$ & Resource member's capacity contribution set of $ms_l$\\
	$q_{\alpha,l}$ & Need resource capacity of $sc_l$ with type $\alpha$\\
	$\bm{\alpha}_l$ & Subset of $\bm{q}_l$ that consists of all the capacities of type $\alpha$ resources in $\bm{mr}_l$\\
	$\mathcal{L}_{l,\tau}$ & The list of job queue of $ms_l$ at $\tau$ with sequence\\
	$\mathcal{G}_{l,\tau}$ & The set of active job of $ms_l$ at $\tau$ \\
	$\mathcal{R}_{ij,\tau}$ & Resource candidates set for $t_{ij}$ to select\\
	$\mathcal{B}_{ij,\tau}$ & Resource candidate types set for $t_{ij}$\\
	$\mathcal{S}_{ij,\tau}$ & Service candidates set for $t_{ij}$ to select\\
	$\mathcal{R}_{l,\tau}$ & Resource candidates set for $sc_l$ to select\\
	$\mathcal{B}_{l,\tau}$ & Resource candidate types set for $sc_l$\\
	$R(\cdot)$ & Rank inquire function about provider\\
	$F(\cdot)$ & Owner inquire function about resource or service\\
	$P(\cdot)$ & Type inquire function about resource type\\
	$\bm{x}$ & Bold font of the variable($x$) means the temp set of a bunch of these variables\\
    \hline
\end{tabularx}
\end{table}
\vspace{-2.5em}
% subsubsection assumptions_nomenclature (end)
\subsubsection{Master plan for original mode} % (fold)
\label{ssub:master_plam}
A single order($o_i$) consists of a set $\mathcal{T}_i = \left\{ t_{i1},t_{i2},\dots\right\}$ of tasks, the tasks are interrelated by kinds of constraints. First, precedence constraints force task $t_{ij}$ not to be started before all its immediate predecessors that come along within order and it can be added in the schedule produce. Second, performing the tasks requires resources with limited capacities. Third, resources cooperation requires all the task parts in active status.
A single resource($mr_k$) belongs to one type in set $\mathcal{A} = \left\{1,2,\dots\right\}$ given by the platform. While being processed via resource cooperation, task $t_{ij}$ requires $q_{\alpha,ij}$ units capacity of the resources with each type $\alpha\in\mathcal{A}_{ij}\subset\mathcal{A}$ during every period of its non-preemptable duration $p_{ij}$. Each resource $mr_k$ has a limited capacity of $C_{k,\tau}$ at any point in time $\tau$. This plan is much like the settings in resource-constrained project scheduling problem\cite{Kolisch1999} except that the task here need multiple types of resource simultaneously.
% subsubsection master_plan (end)
% subsection preliminaries (end)

\subsection{Individual decisions in original mode} % (fold)
\label{sub:interactions_and_decisions}
\subsubsection{Response for type matched task}
\label{subs:Response_for_type_matched_task}
Provider makes decision at time $\tau\ge r_i$ to response task if the belonged resource $mr_k$ was type matched with $t_{ij}$ ($P(mr_k)\in\mathcal{A}_{ij}$). If $A_{k,\tau} \ge q_{\alpha,ij}$, provider will response the task need, demander of $t_{ij}$ will add $mr_k$ to $\mathcal{R}_{ij,\tau}$ and $P(mr_k)$ to $\mathcal{B}_{ij,\tau}$. If $mr_k$ was finally selected, available capacity of $mr_k$ will change as $A_{k,\tau}:= A_{k,\tau} - q_{\alpha,ij}$ , the available capacity will be returned back after the finish of $t_{ij}$ part.

\subsubsection{Select from resource candidates}
\label{subs:select_resource_candidates}
Demander makes decision about resource selection from $\mathcal{R}_{ij,\tau}$ when $\mathcal{B}_{ij,\tau} = \mathcal{A}_{ij}$. W.o.l.o.g, we suppose at time period $\tau \ge r_i$, the decision making of demander can be described as follows:
\begin{equation}
\max_{\forall \bm{k}}\left( \delta_{\bm{k}}, 
R\left( F\left( mr_{\bm{k}} \right) \right), \abs{\mathcal{L}_{\bm{k},\tau} }
\right) \label{eq:selectresaim}
\end{equation}
\begin{numcases}{\text{s.t.}}
q_{\alpha,ij} \le C_{k_{\alpha},\tau} & $\alpha\in\mathcal{A}_{ij}$\label{eq:rescaplimit}\\
\mathcal{R}_{\alpha,\tau} = \left\{ mr| mr\in\mathcal{R}_{ij,\tau}, P(mr) = \alpha \right\} & $\alpha\in\mathcal{A}_{ij}$\label{eq:restypeabstract}\\
\mathcal{R}_{ij,\tau} = \bigcup_{\alpha\in\mathcal{A}_{ij}}\mathcal{R}_{\alpha,\tau} & \label{eq:nrc}\\
\bm{k} = \left[k_1,\dots ,k_\alpha,\dots,k_{\abs{\mathcal{A}_{ij}}} \right] & \label{eq:decisionvectork}\\
k_\alpha \in \left\{ k | mr_k \in \mathcal{R}_{\alpha,\tau} \right\} &$\alpha\in\mathcal{A}_{ij}$ \label{eq:decisionvark}
\end{numcases}

The multi-objective in \autoref{eq:selectresaim} aims at high quality, high resource owner rank and low waiting queue length. \autoref{eq:rescaplimit} makes sure that resource capacity is capable to process the task part, \autoref{eq:restypeabstract}--\ref{eq:nrc} restrict the resource candidates' type in the task configuration, \autoref{eq:decisionvectork}--\ref{eq:decisionvark} describe decision variable, the demander should make decision to select resource in each type of required configuration.

\subsubsection{Assign in selected resource} % (fold)
\label{subs:assign_in_select_resource}
If $mr_k$ was selected by the demander of $t_{ij}$, then the provider will add $t_{ij}$ part to $\mathcal{H}_{k,\tau}$ or $\mathcal{L}_{k,\tau}$ according to:
\begin{subnumcases}{}
\mathcal{H}_{k,\tau} := \mathcal{H}_{k,\tau} \cup \{t_{ij}\} & if $\abs{\mathcal{L}_{k,\tau}}=0,A_{k,\tau}\ge q_{\alpha,ij}$ \label{eq:addtobuffer}\\
\mathcal{L}_{k,\tau} := \mathcal{L}_{k,\tau} \cup \{t_{ij}\} & otherwise
\end{subnumcases}

If all the part of $t_{ij}$ are in type matched resources' $\mathcal{H}_{k,\tau}$, then these providers will change all the task part status from semi-active to active and add $t_{ij}$ to their $\mathcal{G}_{k,\tau}$.
% subsubsection assign_in_selected_resource (end)
% subsection interactions_and_decisions (end)

\subsection{Incubation mode} % (fold)
\label{sub:incubation_mode}
Incubation mode is one extension mode for the original mode, the purpose of this mode is to remove the cooperation and assembly procedure in advance by gathering types of resource with certain quota in a contract. Manufacturing service will be incubated as shown in \autoref{fig:serviceincubatemode}.  
\begin{figure}[htbp]
    \centering
    \resizebox{0.7\textwidth}{!}{\input{figures/service-incubate}}
    \caption{Incubation mode}
    \label{fig:serviceincubatemode}
\end{figure}
After the finish of task part, provider record the resource configuration as task frequency, when the frequency value reached some point, provider will decide to incubate such task-specified service for the future performance.

The first thing of incubation is to publish a job named service-call, which is similar with task except for the capacity dominance and each required resource type can also be cooperated by different resources, which means after the performance of service-call, capacity of selected resource will not be returned to. The product of service-call is the service, which is actually a contract of resources that may come from any provider in the system, it's possible for more than one resource with same type to make contribute to the formation of service. No more cooperation and assembly are part of pros of service and product quality will no more restricted to the worst quality of resources since the complementary effect, while the cons of service include that it can only perform  corresponding configured task.
Now we can mark task and service-call as job, resource and service as machine.

\subsubsection{Response for type matched job} % (fold)
\label{ssub:response_in_type_matched_resource}
Apart from $mr_k$ response for $t_{ij}$ as we explained in \autoref{subs:Response_for_type_matched_task}, there are 2 other cases in incubation mode:
\begin{asparaenum}
\item $mr_k$ response for $sc_l$
\suspend{asparaenum}
If $mr_k$ was type matched with $sc_l$ ($P(mr_k)\in\mathcal{A}_l$), as long as $C_{k,\tau}> 0$, provider of $mr_k$ will response the service-call. If $mr_k$ was finally selected, both available capacity and capacity will change as \autoref{eq:capq}--\ref{eq:cap0}, and these capacity will not be returned back even after the finish of $sc_l$ part. Provider of $sc_l$ will add $mr_k$ to $\mathcal{R}_{l,\tau}$ and $P(mr_k)$ to $\mathcal{B}_{l,\tau}$.
\resume{asparaenum}
\item $ms_l$ response for $t_{ij}$
\end{asparaenum}
Service is task-oriented machine, so if type matched ($\mathcal{A}_{ij} =\mathcal{A}_l,\sum_{q\in\bm{\alpha}_l} q = q_{\alpha,ij}$), provider of it will response $t_{ij}$ as soon as possible, demander will add $ms_l$ to $\mathcal{S}_{ij,\tau}$.

% subsubsection response_in_type_matched_resource (end)

\subsubsection{Select from machine candidates} % (fold)
\label{ssub:selection_in_resource_candidates_for_service_call}
Apart from demander of $t_{ij}$ select $mr_k$ as we explained in \autoref{subs:select_resource_candidates} when $\mathcal{B}_{ij,\tau} = \mathcal{A}_{ij},\abs{\mathcal{S}_{ij,\tau}}=0$, there are 3 other cases in incubation mode:

\begin{asparaenum}
\item Select $mr_k$ for $sc_l$ when $\mathcal{B}_{l,\tau} = \mathcal{A}_l$
\suspend{asparaenum}

The decision making of select from $\mathcal{R}_{l,\tau}$ is similar to \autoref{eq:selectresaim}--\ref{eq:decisionvark}, and the difference is that the every part of $\bm{l}_{\alpha}$ in decision variable $\bm{l}$ here is also a set of selected resources followed by \autoref{eq:capq}--\ref{eq:cap0}, and if the sum of capacity quantity in $\bm{l}_{\alpha}$ less than the $sc_l$ required, this selection will not to be executed.
\begin{subnumcases}{}
C_{k,\tau} := C_{k,\tau} - q_{\alpha,l}& If $C_{k,\tau} \ge q_{\alpha,l}$\label{eq:capq}\\
C_{k,\tau} := 0 & otherwise \label{eq:cap0}
\end{subnumcases}



\resume{asparaenum}
\item Select $ms_l$ for $t_{ij}$ when $\mathcal{B}_{ij,\tau}\subset\mathcal{A}_{ij},|\mathcal{S}_{ij,\tau}|>0$
\suspend{asparaenum}

This situation implies that the resource candidates are not enough while there exists service candidates, demander can just select service. 
\begin{equation}
\max_{\forall l}\left( \Delta_{l}, R\left(F\left(ms_{l}\right)\right), \abs{\mathcal{L}_{l,\tau}}\right)\label{eq:selectserviceaim}
\end{equation}
\begin{numcases}{\text{s.t.}}
\Delta_l \sim \mathcal{N} \left(\mu_l,\sigma_l^2\right) & \label{eq:servicecomplydist}\\
\mu_l = mean\left( \bm{mr}_l , \bm{q}_l \right) & \\
\sigma_l = std\left( \bm{mr}_l , \bm{q}_l \right) & \label{eq:servicecomplydistend}\\
l \in \left\{l' |  ms_{l'} \in \mathcal{S}_{ij,\tau} \right\}  & \label{eq:decisionvariablel}
\end{numcases}

Similar to \autoref{eq:selectresaim}, \autoref{eq:selectserviceaim} is also a multi-objective function that aims at high quality, high service owner rank and low waiting queue length. \autoref{eq:servicecomplydist}--\ref{eq:servicecomplydistend} explain the service quality distribution parameters, \autoref{eq:decisionvariablel} is the decision variable to select one service in $\mathcal{S}_{ij,\tau}$.

\resume{asparaenum}
\item Select machine for $t_{ij}$ when $\mathcal{B}_{ij,\tau} = \mathcal{A}_{ij},\abs{\mathcal{S}_{ij,\tau}}>0$.
\end{asparaenum}

In this situation, demander of $t_{ij}$ will select ether a bunch of resources with cooperation or one single service, so the key idea here is to pre-select optimal resources and optimal service, then to compare these two optimal options to select the better one. 
\begin{equation}
\max_{m\in\{l^*,\bm{k}^*\}} \left( \Delta_m, 
Rank_m, \mathcal{L}_m \right) \\ \label{eq:combaim} 
% \text{s.t.}\notag
\end{equation}
\begin{numcases}{\text{s.t.}}
% q_{\alpha,ij} \le C_{k_{\alpha},\tau} & \footnotesize$\alpha\in\mathcal{A}_{ij}$\\
% R_{\alpha,\tau} = \left\{ mr| mr\in\mathcal{R}_{ij,\tau}, P(mr) = \alpha \right\} & \footnotesize$\alpha\in\mathcal{A}_{ij}$\\
% \mathcal{R}_{ij,\tau} = \bigcup_{\alpha\in\mathcal{A}_{ij}}\mathcal{R}_{\alpha,\tau} & \\
% \bm{k} = \left[k_1,\dots ,k_\alpha,\dots,k_{\abs{\mathcal{A}_{ij}}} \right]& \\
% k_\alpha \in \left\{ k | mr_k \in \mathcal{R}_{\alpha,\tau} \right\} &\footnotesize$\alpha\in\mathcal{A}_{ij}$ \\
\bm{k}^* = \arg\left(\max_{\forall \bm{k}}\left( \delta_{\bm{k}}, 
R\left( F\left( mr_{\bm{k}} \right) \right), \abs{\mathcal{L}_{\bm{k},\tau} }
\right)\right) & \label{eq:optk}\\
Rank_{\bm{k}^*} = \min_{k\in\bm{k}^*} \left\{ R\left( F\left( mr_k \right) \right) \right\} & \label{eq:temprank}\\
\mathcal{L}_{\bm{k}^*} = \max_{k\in\bm{k}^*}\left\{ \abs{\mathcal{L}_{k,\tau}} \right\} & \label{eq:templength}\\
\Delta_{\bm{k}^*} \sim \mathcal{N} \left(\mu_{\bm{k}^*},\sigma_{\bm{k}^*}^2\right) & \label{eq:tempqualitystart}\\
\mu_{\bm{k}^*} = mean\left( \bm{mr}_{\bm{k}^*} , \bm{q}_{\bm{k}^*} \right) & \\
\sigma_{\bm{k}^*} = std\left( \bm{mr}_{\bm{k}^*} , \bm{q}_{\bm{k}^*} \right) & \\
\bm{mr}_{\bm{k}^*} = \bigcup_{k\in\bm{k}^*}mr_k  &\\
\bm{q}_{\bm{k}^*}  =\bigcup_{\alpha\in\mathcal{A}_{ij}}q_{\alpha,ij} & \label{eq:tempqualityend}\\
% \Delta_l \sim \mathcal{N} \left(\mu_l,\sigma_l^2\right) & \\
% \mu_l = mean\left( \bm{mr}_l , \bm{q}_l \right) & \\
% \sigma_l = std\left( \bm{mr}_l , \bm{q}_l \right) & \\
% l \in \left\{l' |  ms_{l'} \in \mathcal{S}_{ij,\tau} \right\}  & \\
l^* = \arg\left( \max_{\forall l}\left(\Delta_{l}, R\left(F\left(ms_{l}\right)\right), \abs{\mathcal{L}_{l,\tau}}\right)  \right) & \label{eq:optl}\\
Rank_{l^*} = R\left( F\left( ms_{l^*} \right) \right) & \\
\mathcal{L}_{l^*} = \abs{\mathcal{L}_{l^*,\tau}} & \\
m \in \left\{ l^*,\bm{k}^* \right\} \label{eq:newdicisionvariable}
\end{numcases}

Similar to other situations, \autoref{eq:combaim} is a a multi-objective function that aims at high quality, high rank and low waiting queue length. \autoref{eq:optk} and \autoref{eq:optl} are the optimal decision in independent conditions, \autoref{eq:temprank}, \autoref{eq:templength} and \autoref{eq:tempqualitystart} are the virtual rank value, virtual queue length and virtual quality value that are set in the worst cases.\autoref{eq:tempqualitystart}--\ref{eq:tempqualityend} are the virtual quality value calculate produce. \autoref{eq:newdicisionvariable} is the decision to choose one of these two partial optimal decision.

% subsubsection selection_in_resource_candidates_for_service_call (end)

\subsubsection{Assign in selected machine} % (fold)
Apart from $mr_k$ assign $t_{ij}$ when selected as we explained in \autoref{subs:assign_in_select_resource}, there are 2 other cases in incubation mode:

\begin{asparaenum}
\item Assign $sc_l$ to $mr_k$
\suspend{asparaenum}

If $mr_k$ is selected by provider of $sc_l$ at time $\tau$, the assign condition is more restrict than that in \autoref{eq:addtobuffer}, it should be changed into $\abs{\mathcal{L}_{k,\tau}} = \abs{\mathcal{G}_{k,\tau}} = \abs{\mathcal{H}_{k,\tau}} = 0$, for the capacity dominance feature of service-call, we need to assign this type of job one by one. Then, the provider of $mr_k$ should change the predecessor set:
\begin{equation}
	\mathcal{P}_l := \mathcal{P}_l\cup \mathcal{L}_{k,\tau} \cup \mathcal{H}_{k,\tau}
\end{equation}
and all the task assign after $\tau$, we say $\tau'>\tau$ will set:
\begin{equation}
	\mathcal{P}_{ij} := \mathcal{P}_{ij}\cup \left\{ sc| sc\in\mathcal{L}_{k,\tau'},sc \text{ is service-call} \right\} \cup \mathcal{H}_{k,\tau'}
\end{equation}
And $A_{k,\tau}$ will be changed with the same amount in \autoref{eq:capq}--\ref{eq:cap0}.
\resume{asparaenum}
\item Assign $t_{ij}$ to $ms_l$
\end{asparaenum}
Assign $t_{ij}$ to $ms_l$ is very simple and there will be no semi-active status for $t_{ij}$, hence:
\begin{subnumcases}{}
\mathcal{G}_{k,\tau} := \mathcal{G}_{k,\tau} \cup \{sc_{l}\} & if $\abs{\mathcal{G}_{k,\tau}}=0$ \\
\mathcal{L}_{k,\tau} := \mathcal{L}_{k,\tau} \cup \{sc_{l}\} & otherwise
\end{subnumcases}

% subsubsection assign_in_selected_machine (end)
% subsection operation_mode (end)

\subsection{Schedule the jobs in machine} % (fold)
\label{sub:schedule_the_jobs_in_machine}
In order to enhance the user rate, provider will schedule the inactive jobs on the provided machines. Since all the jobs in the service are tasks and they have identical configuration, so the schedule in service is a single machine scheduling problem that is not what we focus on in this study, we only discuss the scheduling of jobs in resources. Since the assignment of new service-call will not trigger the schedule procedure because of the resource capacity dominance feature, so it's necessary to suspend service-call in inactive status until all the job before it in $\mathcal{L}_{k,\tau}$ are finished, at the meantime, all the job come after service-call should be stay in inactive status until the service-call is finished, as shown in \autoref{fig:simplejoblist}, service-call likes partition plate in $\mathcal{L}_{k,\tau}$.  
\begin{figure}[htbp]
	\centering
	\resizebox{.75\textwidth}{!}{\input{figures/service-call}}
	\caption{Simple illustration for one $\mathcal{L}_{k,\tau}$}
	\label{fig:simplejoblist}
\end{figure}
Therefore, the we just need to schedule the tasks before the first service-call in $\mathcal{L}_{k,\tau}$ when one of the active job in $\mathcal{G}_{k,\tau}$ was finished at $\tau_0$, we denote the set of schedule task at this time as $\mathcal{L}^{(s)}_{k,\tau_0}$

Specifically, a simple instance with configuration \autoref{tab:simplejobconfiguration} and schedule chart \autoref{fig:scheduleChart} will describe the setting more clearly.

\begin{table}[htbp]
  \centering
  \scriptsize
  \caption{Simple job configuration}
    \begin{tabular}{cccccc}
    \toprule
    \multicolumn{1}{c}{\multirow{2}[0]{*}{ Job}} & \multicolumn{3}{c}{Need Resource Capacity} & \multicolumn{1}{c}{\multirow{2}[0]{*}{Release Time}} & \multicolumn{1}{c}{\multirow{2}[0]{*}{Process Duration}} \\
    \multicolumn{1}{c}{} & $Type_1$ & $Type_2$ & $Type_3$ & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
    \midrule
    $t_1$ & 0     & 5     & 7     & 0     & 7 \\
    $t_2$ & 7     & 5     & 7     & 4     & 5 \\
    $t_3$ & 6     & 0     & 5     & 2     & 3 \\
    $t_4$ & 9	 & 4  & 6 & 1 &2 \\
    $t_5$ & 1 & 0 & 3 & 2 & 3\\
    $sc_1$ & 0     & 0     & 3    & 1     & 1 \\
    $sc_2$ & 2     & 7     & 6     & 3     & 1 \\
    \bottomrule
    \end{tabular}%
  \label{tab:simplejobconfiguration}%
\end{table}%
\begin{figure}[htbp]
	\centering
	\resizebox{.8\textwidth}{!}{\input{figures/scheduleChart}}
	\caption{Simple instance schedule chart with 4 resources}
	\label{fig:scheduleChart}
\end{figure}
This instance makes some simplification in the subscript fields in order to emphasize the resource cooperation, all the job(task and service-call) performance can only be started when the each of the related resource is ready, so the shadow in the figure is the waiting period. Horizontal dotted line constrained the available capacity of the resource for the following jobs, every performance of service-call will make the line lower and it will never get higher again unless the related service is repealed.


A schedule is given by a vector of ideal finish times $\bm{f}^{(s)} = \left[f_1^{(s)}, f_2^{(s)},\dots,f^{s}_n\right],n=\abs{\mathcal{L}^{(s)}_{k,\tau_0}}$. Since the task in $\mathcal{L}^{(s)}_{k,\tau_0}$ and $\mathcal{G}_{k,\tau_0}$ may come from different orders, we here use the single uniform subscript $j$ to distinguish these tasks and their related variables, type subscript $\alpha$ can be ignored for all the job assigned here matches the resource type, so the schedule model is:

\begin{equation}
\min_{\forall\bm{f}^{(s)}}\left( \max_{j\in L^{(s)}}\left\{ f_j^{(s)} - r_j - p_j \right\} \right)
\end{equation}
\begin{numcases}{\text{s.t.}}
L^{(s)} = \left\{j| t_{j}\in \mathcal{L}^{(s)}_{k,\tau_0}\right\} & \\
f^{(s)}_h \le f_j^{(s)} - p_j & $h\in\mathcal{P}_j$,$j\in L^{(s)}$\\
G^{(s)} = \left\{j' | t_{j'}\in \mathcal{G}_{k,\tau_0}\right\} & \\
f^{(s)}_j =  \tau_0 + re_j & $j\in G^{(s)}$ \\
\sum_{j\in\left\{  j' |t_{j'} \in\mathcal{G}_{k,\tau}\right\}} q_j \le A_{k,\tau}& $\tau \ge \tau_0$ \label{eq:caplimitwithtime} \\
f^{(s)}_j \ge \tau_0 + p_j & $j\in L^{(s)}$
\end{numcases}

Like the RCPSP.
Since \autoref{eq:caplimitwithtime} is a time dependent function the schedule model cannot be
solved with mixed integer programming (MIP) techniques. In order to solve
the RCPSP with MIP{solvers such as CPLEX (cf. Bixby 1996), one has to
employ the 0{1 problem formulation of Pritsker et al. (1969).}}

% subsection schedule_the_jobs_in_machine (end)


\subsection{Outsource mode} % (fold)
\label{sub:outsource_mode}


\begin{figure}[htbp]
    \centering
    \resizebox{0.7\textwidth}{!}{\input{figures/outsource}}
    \caption{Outsource mode}
    \label{fig:outsourcemode}
\end{figure}

Since only matched task can be assigned and processed in the certain service, the decision making about schedule tasks in service $ms_l$ is a simple problem that it is similar to 1 machine scheduling problem, so we will not discuss the situation about schedule the task in $\mathcal{L}_{l,\tau}$ here. However, service can perform task in a flexible mode, provider can outsource the task in both active and inactive status.

For each single task $t_j\in\mathcal{L}_{l,\tau}\cup\mathcal{G}_{l,\tau}$, the only condition to make the outsource decision is that if the maximum delay($f_j-p_j-r_j$) of task in both status will decrease. This decision highly depends on the estimate of performance status in other resources and services.
% subsection outsource_mode (end)


\subsection{Metabolism mode} % (fold)
\label{sub:metabolism mode}

\begin{figure}[htbp]
    \centering
    \resizebox{0.85\textwidth}{!}{\input{figures/metabolism}}
    \caption{Metabolism mode}
    \label{fig:metabolismmode}
\end{figure}
The decision makings explained above are controlled by review and ranking mechanism provided by platform, the provider who have higher rank value will be safer to stay in the ecosystem, have more chance to succeed in generating services, his services and resources will get more preference. Hence, here we will explain some controlling rules related to the rank value changing:
\begin{asparaenum}
\item Review from demander when his task $t_{ij}$ was finished by resource cooperation $mr_{\bm{k}}$:
\suspend{asparaenum}

We will ignore resource type subscript $\alpha$ here for the reason that resources perform the task already meet the type needs. With the assumption given above, higher resource occupation($p_{ij}\cdot q_{ij}$), lower delay($f_{ij} - p_{ij} - r_{ij}$), larger difference between actual and expected product quality($\delta_{ij}-\gamma_{ij}$), will turn out higher rank value($rank$) changing:
\begin{subnumcases}{}
rank := rank +
\frac{\left( p_{ij}\cdot q_{ij} \right) \left( \delta_{ij}-\gamma_{ij} \right)}{e^{\left(f_{ij} - p_{ij} -r_{ij}\right)}} & $k\in\bm{k}$\\
\delta_{ij} = \min_{k\in\bm{k}}\left\{ \delta_k \right\} & \\
\delta_k \sim \mathcal{N}\left(\mu_k,\sigma_k^2 \right) & $k\in\bm{k}$
\end{subnumcases} 

\resume{asparaenum} 
\item Review from demander when his task $t_{ij}$ was finished by service $ms_l$:
\suspend{asparaenum}
Rank value changing with regard to service can be determined easier:
\begin{equation}
	rank := rank + \frac{ \left(\sum_{q\in\bm{q}_l}p_{ij}\cdot q \right)\left( \Delta_l -\gamma_{ij}\right) }{ e^{\left( f_{ij} - p_{ji} -r_{ij} \right)} }
\end{equation}

\resume{asparaenum}
\item Eliminate resource or service on the platform
\end{asparaenum}

This decision making is a control method for platform to keep the performance of tasks with content quality and efficiency. We denote the list of all resources with type $\alpha$ as $\bm{mr}_\alpha$ and the list of all services as $\bm{ms}$ at time $\tau$, after the sort these lists according to the scarcity and quality, the unqualified resources and services. Scarcity can be defined as:

\begin{subnumcases}{}
\sum_{k\in\{k|mr_k\in\bm{mr}_\alpha\}}\abs{\mathcal{L}_{k,\tau} } & $\alpha\in\mathcal{A}$ \label{eq:resourcescarcity}\\ 
\abs{\mathcal{L}_{l,\tau}} & \label{eq:servicescarcity}
\end{subnumcases}

The scarcity of one service can be calculated with \autoref{eq:servicescarcity} while the scarcity of one type of resource can be calculated with \autoref{eq:resourcescarcity}.
% subsection controlling_rules (end)

\subsection{Tricky problem} % (fold)
\label{sub:tricky_problems}
Even though the schedule mode exclude the interference of service-call, one tricky problem will occur that it will block some tasks from being processed. Suppose that $t_{i1}$ and $t_{i2}$ both need resource $mr_1$ and $mr_2$, as shown in \autoref{fig:joblock}, 
\begin{figure}[htbp]
	\centering
	\resizebox{.75\textwidth}{!}{\input{figures/job-lock}}
	\caption{Simple illustration of job lock problem}
	\label{fig:joblock}
\end{figure}
$t_{i2}$ is active in $mr_2$ and inactive in $mr_1$, while $t_{i1}$ is active in $mr_1$ and inactive in $mr_2$, because of the capacity limit, there is no more space for inactive tasks to stack in, so no matter how long the resource will wait, $t_{i1}$ and $t_i2$ will not be processed and will they will block the other tasks from being processed.

The method to solve the job-lock problem is to add the status changed task to the predecessor set of all the other tasks in the same inactive queue list.
% subsection tricky_problems (end)
% section design_of_the_ecosystem (end)
