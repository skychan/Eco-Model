% !TEX root = Eco-Model.tex
\section{Design of the ecosystem} % (fold)
\label{sec:design_of_the_ecosystem}
\subsection{Preliminaries} % (fold)
\label{sub:preliminaries}
The manufacturing ecosystem we proposed in this paper consists of the structure of cloud manufacturing, the operation mode and the controlling rules. Before the detailed interpretation for these parts, we describe some basic settings as follows.

\subsubsection{Master plan} % (fold)
\label{ssub:master_plam}
With the cloud manufacturing platform operating, demander comes, signs up and publish orders, the structure of the order is depicted by a so-called activity-on-node(AON) network where the nodes represent the tasks and the arcs the precedence relations. Match module in platform informs the task messages to every matched resources and services. After the select decision makes by the demander, the selected resources and services prepare to the performance of the task.
Providers find frequent task after a bunch of successful accomplishment via resource reviews, then another type of job, service-call generated by them to gather certain type and amount of resources registered in the platform to create service in order to perform the certain task more efficient than before. Most of resource related decision making are well controlled by platform with the review module.

A single order($o_i$) consists of a set $\mathcal{T}_i = \left\{ t_{i1},t_{i2},\dots\right\}$ of tasks which have to be processed. The tasks are interrelated by kinds of constraints. First, precedence constraints force task $t_{ij}$ not to be started before all its immediate predecessors, how to construct the predecessor will be explained later. Second, performing the tasks requires resources with limited capacities. Third, resources cooperation transmits and enhances these constraints.

A single resource($mr_k$) belongs to one type in set $\mathcal{A} = \left\{1,2,\dots\right\}$ given by the platform. While being processed via resource cooperation, task $t_{ij}$ requires $q_{k,ij}$ units amount of the resources with every type in $\mathcal{A}_{ij}\subset\mathcal{A}$ during every period of its non-preemptable duration $p_{ij}$. Each resource $mr_k$ has a limited capacity of $C_k(\tau)$ at any point in time $\tau$.

A single service($s_l$) is a composition of all resources in set $R_l$ with their partial capacities, it can only process certain task with matched resource configuration($\mathcal{A}_{ij}=\mathcal{A}_l$,$ Q_{ij}(\cdot)=Q_l(\cdot)$) without resource coordinating any more. While being processed via one matched service, task can be suspended then outsourced to other matched service or resource cooperation.
Resource comes along with provider when it enter the ecosystem, however, service doesn't, service is generated after a period of time, the prototype of a service is another type of job, we call it the service-call.

A single service-call($sc_l$) comes out after the finish of one frequent task, so it have the same resource configuration the frequent task. Service-call can only be performed via resource cooperation with duration $p_l$, because the identity of resource, the capacity cannot be return to the resource after the finish of service-call, so the service-call brings new constrains to the related resources. Unlike the task, the amount of one type resource required in the service-call can be pieced together from more than one resource as long as they are in the same type.

Specifically, a simple instance with configuration \autoref{tab:simplejobconfiguration} and schedule chart \autoref{fig:scheduleChart} will describe the setting more clearly.
% \begin{table}[htbp]
%   \centering
%   \scriptsize
%   \caption{Simple resource configuration}
%     \begin{tabular}{ccc}
%     \toprule
%     Resource & Type  & Capacity \\
%     \midrule
%     $r_1$ & 1     & 10 \\
%     $r_2$ & 2     & 10 \\
%     $r_3$ & 3     & 10 \\
%     $r_4$ & 3     & 10 \\
%     \bottomrule
%     \end{tabular}%
%   \label{tab:simpleresourceconfiguration}%
% \end{table}%
\begin{table}[htbp]
  \centering
  \scriptsize
  \caption{Simple job configuration}
    \begin{tabular}{cccccc}
    \toprule
    \multicolumn{1}{c}{\multirow{2}[0]{*}{ Job}} & \multicolumn{3}{c}{Need Resource Capacity} & \multicolumn{1}{c}{\multirow{2}[0]{*}{Release Time}} & \multicolumn{1}{c}{\multirow{2}[0]{*}{Process Duration}} \\
    \multicolumn{1}{c}{} & $Type_1$ & $Type_2$ & $Type_3$ & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
    \midrule
    $t_1$ & 0     & 5     & 7     & 0     & 7 \\
    $t_2$ & 7     & 5     & 7     & 4     & 5 \\
    $t_3$ & 6     & 0     & 5     & 2     & 3 \\
    $t_4$ & 9	 & 4  & 6 & 1 &2 \\
    $t_5$ & 1 & 0 & 3 & 2 & 3\\
    $sc_1$ & 0     & 0     & 3    & 1     & 1 \\
    $sc_2$ & 2     & 7     & 6     & 3     & 1 \\
    \bottomrule
    \end{tabular}%
  \label{tab:simplejobconfiguration}%
\end{table}%
\begin{figure}[htbp]
	\centering
	\resizebox{.8\textwidth}{!}{\input{figures/scheduleChart}}
	\caption{Simple instance schedule chart with 4 resources}
	\label{fig:scheduleChart}
\end{figure}
This instance makes some simplification in the subscript fields in order to emphasize the resource cooperation, all the job(task and service-call) performance can only be started when the each of the related resource is ready, so the shadow in the figure is the waiting period. Horizontal dotted line constrained the available capacity of the resource for the following jobs, every performance of service-call will make the line lower and it will never get higher again unless the related service is repealed.

% subsubsection master_plan (end)

\subsubsection{Assumptions, nomenclature} % (fold)
\label{ssub:assumptions_nomenclature}
Assumptions about quality

about time

schedule and outsource are event driven decision making 

resources are renewable

\begin{table}[htbp]
  \scriptsize
\begin{tabularx}{\textwidth}{|lX|}
    \hline
    \multicolumn{2}{|l|}{\multirow{2}[0]{*}{\large\textbf{Nomencalture}}} \\
    \multicolumn{2}{|l|}{} \\
	$o_i$ & Order that come with demander \\
	$\mathcal{T}_i$ & Task set of $o_i$ \\
	$t_{ij}$ & Task belongs to $o_i$, $t_{ij}\in\mathcal{T}_i$ \\
	$p_{ij}$ & Process duration of $t_{ij}$\\
	$\gamma_{ij}$ & Expect quality of product after the finish of $t_{ij}$\\
	$r_i$ & Release time of $o_i$\\
	$f_{ij}$ & Actual finish time of $t_{ij}$ \\
	$f_{i}$ & Finish time of $o_i$\\
	$\mathcal{P}_{ij}$ & The set of predecessor of $t_{ij}$\\
	$mr_k$ & Resource that come with provider \\
	$\delta_k$ & Product quality produced via resource $mr_k$ \\
	$C_{k,\tau}$ & Capacity of $mr_k$ at time $\tau$\\
	$A_{k,\tau}$ & Available capacity of $mr_k$ at time $\tau$\\
	$\mathcal{L}_{k,\tau}$ & The list of job queue of $mr_k$ at $\tau$ with sequence\\
	$\mathcal{G}_{k,\tau}$ & The set of active job (being processed) of $mr_k$ at $\tau$ \\ 
	$f^{(s)}_j$ & Ideal finish time of $t_j$ in $\mathcal{L}^{(s)}_{k,\tau_0}$ for schedule . \\
	$re_j$ & Remaining process time of $t_j$ in $\mathcal{G}_{k,\tau_0}$ for schedule . \\
	$\mathcal{A}$ & Resource type set \\
	$\mathcal{A}_{ij}$ & Resource type subset required by $t_{ij}$, $\mathcal{A}_{ij}\subset\mathcal{A}$\\
	$q_{\alpha,ij}$ & Required amount of resource with type $\alpha$ by $t_{ij}$\\
	$sc_l$ & Service-call generated by provider\\
	$p_l$ & Process duration of $sc_l$\\
	$r_l$ & Release time of $sc_l$\\
	$\mathcal{P}_{l}$ & The set of predecessor of $sc_{l}$\\
	$\mathcal{A}_l$ & Resource type subset required by $sc_l$ or provided by $ms_l$ , $\mathcal{A}_l\subset\mathcal{A}$\\
	$ms_l$ & Service that generated after the finish of $sc_l$\\
	$\Delta_l$ & Product quality produced via service $ms_l$\\
	$\bm{mr}_l$ & Resource member set of $ms_l$\\
	$\bm{q}_l$ & Resource member's capacity contribution set of $ms_l$\\
	$\mathcal{L}_{l,\tau}$ & The list of job queue of $ms_l$ at $\tau$ with sequence\\
	$\mathcal{G}_{k,\tau}$ & The set of active job (being processed) of $ms_l$ at $\tau$ \\
	$\mathcal{R}_{ij,\tau}$ & Resource candidates set for $t_{ij}$ to select\\
	$\mathcal{B}_{ij,\tau}$ & Resource candidate types set for $t_{ij}$\\
	$\mathcal{S}_{ij,\tau}$ & Service candidates set for $t_{ij}$ to select\\
	$\mathcal{R}_{l,\tau}$ & Resource candidates set for $sc_l$ to select\\
	$\mathcal{B}_{l,\tau}$ & Resource candidate types set for $sc_l$\\
	$R(\cdot)$ & Rank inquire function about provider\\
	$F(\cdot)$ & Owner inquire function about resource or service\\
	$P(\cdot)$ & Type inquire function about resource type\\
	$\bm{x}$ & Bold font of the variable($x$) means the temp set of a bunch of these variables\\
    \hline
\end{tabularx}
\end{table}

For the continuous coming of provider, demander, order, task, etc., the amount of them can not be determined at any time point, so we doesn't restrict the upper bound for subscript index amount of all these variables, and we will study the decision separately for these individual at the given time point $\tau$. Detailed design will be explained in the following sections.
% subsubsection assumptions_nomenclature (end)
% subsection preliminaries (end)

\subsection{Interactions and decisions} % (fold)
\label{sub:interactions_and_decisions}
\subsubsection{Demander}
\label{subs:Demander}
Demander makes decision about resources and services selection for the task. Without loss of generalization, we suppose at time period $\tau$, demander received bunch of matched resource and services as candidates for the performance of the published order $o_i$, it's obvious that $\tau \ge r_{i}$. The decision making for any task included in $o_i$, let's take $t_{ij}$, can be described in one of the following 3 situation:

\begin{asparaenum}
\item $\mathcal{B}_{ij,\tau}\subset\mathcal{A}_{ij}$, while $|\mathcal{S}_{ij,\tau}|>0$.
\suspend{asparaenum}
\begin{equation}
\max_{\forall l}\left( \Delta_{l}, R\left(F\left(ms_{l}\right)\right), \abs{\mathcal{L}_{l,\tau}}\right)
\end{equation}
\begin{numcases}{\text{s.t.}}
\Delta_l \sim \mathcal{N} \left(\mu_l,\sigma_l^2\right) & \\
\mu_l = mean\left( \bm{mr}_l , \bm{q}_l \right) & \\
\sigma_l = std\left( \bm{mr}_l , \bm{q}_l \right) & \\
l \in \left\{l' |  ms_{l'} \in \mathcal{S}_{ij,\tau} \right\}  & 
\end{numcases}

\resume{asparaenum}
\item  $\mathcal{B}_{ij,\tau} = \mathcal{A}_{ij}$, while $\abs{\mathcal{S}_{ij,\tau}}=0$.
\suspend{asparaenum}

\begin{equation}
\max_{\forall \bm{k}}\left( \delta_{\bm{k}}, 
R\left( F\left( mr_{\bm{k}} \right) \right), \abs{\mathcal{L}_{\bm{k},\tau} }
\right)
\end{equation}

\begin{numcases}{\text{s.t.}}
q_{\alpha,ij} \le C_{k_{\alpha},\tau} & $\alpha\in\mathcal{A}_{ij}$\\
R_{\alpha,\tau} = \left\{ mr| mr\in\mathcal{R}_{ij,\tau}, P(mr) = \alpha \right\} & $\alpha\in\mathcal{A}_{ij}$\\
\mathcal{R}_{ij,\tau} = \bigcup_{\alpha\in\mathcal{A}_{ij}}\mathcal{R}_{\alpha,\tau} & \\
\bm{k} = \left[k_1,\dots ,k_\alpha,\dots,k_{\abs{\mathcal{A}_{ij}}} \right] & \\
k_\alpha \in \left\{ k | mr_k \in \mathcal{R}_{\alpha,\tau} \right\} &$\alpha\in\mathcal{A}_{ij}$
\end{numcases}
For each required resource type $\alpha$

\resume{asparaenum}
\item  $\mathcal{B}_{ij,\tau} = \mathcal{A}_{ij}$, while $\abs{\mathcal{S}_{ij,\tau}}>0$.
\end{asparaenum}

\begin{equation}
\max_{m\in\{l^*,\bm{k}^*\}} \left( \Delta_m, 
Rank_m, \mathcal{L}_m \right) \\ 
% \text{s.t.}\notag
\end{equation}
\begin{numcases}{\text{s.t.}}
% q_{\alpha,ij} \le C_{k_{\alpha},\tau} & \footnotesize$\alpha\in\mathcal{A}_{ij}$\\
% R_{\alpha,\tau} = \left\{ mr| mr\in\mathcal{R}_{ij,\tau}, P(mr) = \alpha \right\} & \footnotesize$\alpha\in\mathcal{A}_{ij}$\\
% \mathcal{R}_{ij,\tau} = \bigcup_{\alpha\in\mathcal{A}_{ij}}\mathcal{R}_{\alpha,\tau} & \\
% \bm{k} = \left[k_1,\dots ,k_\alpha,\dots,k_{\abs{\mathcal{A}_{ij}}} \right]& \\
% k_\alpha \in \left\{ k | mr_k \in \mathcal{R}_{\alpha,\tau} \right\} &\footnotesize$\alpha\in\mathcal{A}_{ij}$ \\
\bm{k}^* = \arg\left(\max_{\forall \bm{k}}\left( \delta_{\bm{k}}, 
R\left( F\left( mr_{\bm{k}} \right) \right), \abs{\mathcal{L}_{\bm{k},\tau} }
\right)\right) & \\
Rank_{\bm{k}^*} = \min_{k\in\bm{k}^*} \left\{ R\left( F\left( mr_k \right) \right) \right\} & \\
\mathcal{L}_{\bm{k}^*} = \max_{k\in\bm{k}^*}\left\{ \abs{\mathcal{L}_{k,\tau}} \right\} & \\
\Delta_{\bm{k}^*} \sim \mathcal{N} \left(\mu_{\bm{k}^*},\sigma_{\bm{k}^*}^2\right) & \\
\mu_{\bm{k}^*} = mean\left( \bm{mr}_{\bm{k}^*} , \bm{q}_{\bm{k}^*} \right) & \\
\sigma_{\bm{k}^*} = std\left( \bm{mr}_{\bm{k}^*} , \bm{q}_{\bm{k}^*} \right) & \\
\bm{mr}_{\bm{k}^*} = \bigcup_{k\in\bm{k}^*}mr_k  &\\
\bm{q}_{\bm{k}^*}  =\bigcup_{\alpha\in\mathcal{A}_{ij}}q_{\alpha,ij} & \\
% \Delta_l \sim \mathcal{N} \left(\mu_l,\sigma_l^2\right) & \\
% \mu_l = mean\left( \bm{mr}_l , \bm{q}_l \right) & \\
% \sigma_l = std\left( \bm{mr}_l , \bm{q}_l \right) & \\
% l \in \left\{l' |  ms_{l'} \in \mathcal{S}_{ij,\tau} \right\}  & \\
l^* = \arg\left( \max_{\forall l}\left(\Delta_{l}, R\left(F\left(ms_{l}\right)\right), \abs{\mathcal{L}_{l,\tau}}\right)  \right) & \\
Rank_{l^*} = R\left( F\left( ms_{l^*} \right) \right) & \\
\mathcal{L}_{l^*} = \abs{\mathcal{L}_{l^*,\tau}} & \\
m \in \left\{ l^*,\bm{k}^* \right\} 
\end{numcases}


\subsubsection{Provider}
\label{subs:Provider}
Provider makes decision for job response with regard to its resources and service, the job here is the generalization of task and service-call. As we mentioned in the master plan, provider publish service-call according to the frequent accomplished tasks. Without loss of generalization, we suppose at time $\tau$, demander will make these decisions:

\begin{asparaenum}
\item Response for the task need $t_{ij}$($\tau\ge r_i$) with resource $mr_k$
\suspend{asparaenum}
\begin{subnumcases}{}
A_{k,\tau} \ge q_{\alpha,ij} &\\
P(mr_k) = \alpha & 
\end{subnumcases}
If $mr_k$ meets the above condition, provider of it will response the task need, demander of $t_{ij}$ will add $mr_k$ to $\mathcal{R}_{ij,\tau}$. If $mr_k$ was finally chose, available of $mr_k$ will change as $A_{k,\tau}:= A_{k,\tau} - q_{\alpha,ij}$. The available will be return back after the finish of $t_{ij}$.
\resume{asparaenum}
\item Response for the service-call need $sc_l$($\tau\ge r_l$) with resume $mr_k$
\suspend{asparaenum}
\begin{subnumcases}{}
C_{k,\tau} > 0 & \\
P(mr_k) = \alpha
\end{subnumcases}
If $mr_k$ meets the above condition, provider($p_a$) of it will response the service-call need, the provider($p_b$) of $sc_l$ will add $mr_k$ to $\mathcal{R}_{l,\tau}$, it's possible to let $p_a=p_b$. If $mr_k$ was finally chose, capacity of $mr_k$ will change as:
\begin{subnumcases}{}
C_{k,\tau} := C_{k,\tau} - q_{\alpha,l}& If $C_{k,\tau} \ge q_{\alpha,l}$\\
C_{k,\tau} := 0 & otherwise
\end{subnumcases}

Capacity will not return back to $mr_k$ until the corresponding service $ms_l$ was repealed. Decision making of provider $p_b$ likes the one of demander's, but the final decision $\bm{mr}_l$ and $\bm{q}_l$ don't have to meet $\abs{\bm{mr}_l} = \abs{\mathcal{A}_{ij}}$, because different resource with the same type can gather together to bundle into one service, the only condition in need is that
\begin{subnumcases}{}
\sum_{k\in\mathcal{R}_{\alpha,\tau}} q_{\alpha,k} = q_{\alpha,l} & $\forall\alpha\in\mathcal{A}_l$\\
R_{\alpha,\tau} = \left\{ mr| mr\in\mathcal{R}_{l,\tau}, P(mr) = \alpha \right\} & $\forall\alpha\in\mathcal{A}_l$
\end{subnumcases}
\resume{asparaenum}
\item Response for the task need $t_{ij}$($\tau\ge r_i$) with service $ms_l$.
\end{asparaenum}
Service is a combination contract among the participated resources and it's made oriented to the certain task, so the only condition for $ms_l$ to response $t_{ij}$ is:
\begin{subnumcases}{}
q_{\alpha,ij} = q_{\alpha,l} & $\forall\alpha\in\mathcal{B}_l$\\
\mathcal{A}_{ij} = \mathcal{B}_l
\end{subnumcases}

This condition is much same as service-call need $sc_l$ after the accomplishment frequent task $t_{ij}$:
\begin{subnumcases}{}
q_{\alpha,ij} = q_{\alpha,l} & $\forall\alpha\in\mathcal{A}_l$\\
\mathcal{A}_{ij} = \mathcal{A}_l
\end{subnumcases}
% subsection interactions_and_decisions (end)

\subsection{Operation mode} % (fold)
\label{sub:operation_mode}
The chief decision making about operation mode for provider is the job schedule method outsource mode, as we mentioned in the master plan, provider makes these decision to arrange the job for a better performance in the process procedure. Because of the event driven assumptions, we again suppose that both a new task was assigned to service or resource and a job was finished at time $\tau$, provider will make decision in the following conditions:
\begin{asparaenum}
\item Assign new task $t_{ij}$ in $mr_k$.
\suspend{asparaenum}

With the select decision of $t_{ij}$ to assign on $mr_k$ at $\tau$, the first thing for the provider of $mr_k$ is to set the predecessor set:
\begin{equation}
	\mathcal{P}_{ij} := \mathcal{P}_{ij}\cup \left\{ sc| sc\in\mathcal{L}_{k,\tau},sc \text{ is service-call} \right\} \cup \mathcal{G}_{k,\tau}
\end{equation}
Then, the provider will add $t_{ij}$ to queue or process buffer according to:
\begin{subnumcases}{}
\mathcal{G}_{k,\tau} := \mathcal{G}_{k,\tau} \cup \{t_{ij}\} & if $\abs{\mathcal{L}_{k,\tau}}=0,A_{k,\tau}\ge q_{\alpha,ij}$ \\
\mathcal{L}_{k,\tau} := \mathcal{L}_{k,\tau} \cup \{t_{ij}\} & otherwise
\end{subnumcases}

\resume{asparaenum}
\item Assign new service-call $sc_l$ in $mr_k$.
\suspend{asparaenum}

With the select decision of $sc_l$ to assign on $mr_k$ at $\tau$, the first thing for the provider of $mr_k$ is to set the predecessor set:
\begin{equation}
	\mathcal{P}_l := \mathcal{P}_l\cup \mathcal{L}_{k,\tau} \cup \mathcal{G}_{k,\tau}
\end{equation}
Then, the provider will add $sc_l$ to queue or process buffer according to:
\begin{subnumcases}{}
\mathcal{G}_{k,\tau} := \mathcal{G}_{k,\tau} \cup \{sc_l\} & if $\abs{\mathcal{L}_{k,\tau}\cup\mathcal{G}_{k,\tau}}=0$ \\
\mathcal{L}_{k,\tau} := \mathcal{L}_{k,\tau} \cup \{t_{ij}\} & otherwise
\end{subnumcases}

\resume{asparaenum}
\item Schedule the tasks in $\mathcal{L}_{k,\tau}$.
\suspend{asparaenum}

The assignment of new service-call will not driven these decision making event because of the resource capacity consuming feature, so it's necessary to suspend service-call in inactive status until all the job before it in $\mathcal{L}_{k,\tau}$ are finished, at the meantime, all the job come after service-call should be stay in inactive status until the service-call is finished, as shown in \autoref{fig:simplejoblist}, service-call likes partition plate in $\mathcal{L}_{k,\tau}$.  
\begin{figure}[htbp]
	\centering
	\resizebox{.75\textwidth}{!}{\input{figures/service-call}}
	\caption{Simple illustration for one $\mathcal{L}_{k,\tau}$}
	\label{fig:simplejoblist}
\end{figure}
Therefore, the we just need to schedule the tasks before the first service-call in $\mathcal{L}_{k,\tau}$ when one of the active job in $\mathcal{G}_{k,\tau}$ was finished at $\tau_0$, we denote the set of schedule task at this time as $\mathcal{L}^{(s)}_{k,\tau_0}$

A schedule is given by a vector of ideal finish times $\bm{f}^{(s)} = \left[f_1^{(s)}, f_2^{(s)},\dots,f^{s}_n\right],n=\abs{\mathcal{L}^{(s)}_{k,\tau_0}}$. Since the task in $\mathcal{L}^{(s)}_{k,\tau_0}$ and $\mathcal{G}_{k,\tau_0}$ may come from different orders, we here use the single uniform subscript $j$ to distinguish these tasks and their related variables, type subscript $\alpha$ can be ignored for all the job assigned here matches the resource type, so the schedule model is:

\begin{equation}
\min_{\forall\bm{f}^{(s)}}\left( \max_{j\in L^{(s)}}\left\{ f_j^{(s)} - r_j - p_j \right\} \right)
\end{equation}
\begin{numcases}{\text{s.t.}}
L^{(s)} = \left\{j| t_{j}\in \mathcal{L}^{(s)}_{k,\tau_0}\right\} & \\
f^{(s)}_h \le f_j^{(s)} - p_j & $h\in\mathcal{P}_j$,$j\in L^{(s)}$\\
G^{(s)} = \left\{j' | t_{j'}\in \mathcal{G}_{k,\tau_0}\right\} & \\
f^{(s)}_j =  \tau_0 + re_j & $j\in G^{(s)}$ \\
\sum_{j\in\left\{  j' |t_{j'} \in\mathcal{G}_{k,\tau}\right\}} q_j \le A_{k,\tau}& $\tau \ge \tau_0$ \label{eq:caplimitwithtime} \\
f^{(s)}_j \ge \tau_0 + p_j & $j\in L^{(s)}$
\end{numcases}

Like the RCPSP.
Since \autoref{eq:caplimitwithtime} is a time dependent function the schedule model cannot be
solved with mixed integer programming (MIP) techniques. In order to solve
the RCPSP with MIP{solvers such as CPLEX (cf. Bixby 1996), one has to
employ the 0{1 problem formulation of Pritsker et al. (1969).}}

\resume{asparaenum}
\item Outsource the task in both active and inactive status.
\end{asparaenum}

Since only matched task can be assigned and processed in the certain service, the decision making about schedule tasks in service $ms_l$ is a simple problem that it is similar to 1 machine scheduling problem, so we will not discuss the situation about schedule the task in $\mathcal{L}_{l,\tau}$ here. However, service can perform task in a flexible mode, provider can outsource the task in both active and inactive status.

For each single task $t_j\in\mathcal{L}_{l,\tau}\cup\mathcal{G}_{l,\tau}$, the only condition to make the outsource decision is that if the maximum delay($f_j-p_j-r_j$) of task in both status will decrease. This decision highly depends on the estimate of performance status in other resources and services.

% subsection operation_mode (end)

\subsection{Controlling rules} % (fold)
\label{sub:controlling_rules}
The decision makings explained above are controlled by review and ranking mechanism provided by platform, the provider who have higher rank value will be safer to stay in the ecosystem, have more chance to succeed in generating services, his services and resources will get more preference. Hence, here we will explain some controlling rules related to the rank value changing:
\begin{asparaenum}
\item Review from demander when his task $t_{ij}$ was finished by resource cooperation $mr_{\bm{k}}$:
\suspend{asparaenum}

We will ignore resource type subscript $\alpha$ here for the reason that resources perform the task already meet the type needs. With the assumption given above, higher resource occupation($p_{ij}\cdot q_{ij}$), lower delay($f_{ij} - p_{ij} - r_{ij}$), larger difference between actual and expected product quality($\delta_{ij}-\gamma_{ij}$), will turn out higher rank value($rank$) changing:
\begin{subnumcases}{}
rank := rank +
\frac{\left( p_{ij}\cdot q_{ij} \right) \left( \delta_{ij}-\gamma_{ij} \right)}{e^{\left(f_{ij} - p_{ij} -r_{ij}\right)}} & $k\in\bm{k}$\\
\delta_{ij} = \min_{k\in\bm{k}}\left\{ \delta_k \right\} & \\
\delta_k \sim \mathcal{N}\left(\mu_k,\sigma_k^2 \right) & $k\in\bm{k}$
\end{subnumcases} 

\resume{asparaenum} 
\item Review from demander when his task $t_{ij}$ was finished by service $ms_l$:
\suspend{asparaenum}
Rank value changing with regard to service can be determined easier:
\begin{equation}
	rank := rank + \frac{ \left(\sum_{q\in\bm{q}_l}p_{ij}\cdot q \right)\left( \Delta_l -\gamma_{ij}\right) }{ e^{\left( f_{ij} - p_{ji} -r_{ij} \right)} }
\end{equation}

\resume{asparaenum}
\item Eliminate resource or service on the platform
\end{asparaenum}

This decision making is a control method for platform to keep the performance of tasks with content quality and efficiency. We denote the list of all resources with type $\alpha$ as $\bm{mr}_\alpha$ and the list of all services as $\bm{ms}$ at time $\tau$, after the sort these lists according to the scarcity and quality, the unqualified resources and services. Scarcity can be defined as:

\begin{subnumcases}{}
\sum_{k\in\{k|mr_k\in\bm{mr}_\alpha\}}\abs{\mathcal{L}_{k,\tau} } & $\alpha\in\mathcal{A}$ \label{eq:resourcescarcity}\\ 
\abs{\mathcal{L}_{l,\tau}} & \label{eq:servicescarcity}
\end{subnumcases}

The scarcity of one service can be calculated with \autoref{eq:servicescarcity} while the scarcity of one type of resource can be calculated with \autoref{eq:resourcescarcity}.
% subsection controlling_rules (end)

\subsection{Tricky problems} % (fold)
\label{sub:tricky_problems}
Even though the schedule mode exclude the interference of service-call, one tricky problem will occur that it will block some tasks from being processed. Suppose that $t_{i1}$ and $t_{i2}$ both need resource $mr_1$ and $mr_2$, as shown in \autoref{fig:joblock}, 
\begin{figure}[htbp]
	\centering
	\resizebox{.75\textwidth}{!}{\input{figures/job-lock}}
	\caption{Simple illustration of job lock problem}
	\label{fig:joblock}
\end{figure}
$t_{i2}$ is active in $mr_2$ and inactive in $mr_1$, while $t_{i1}$ is active in $mr_1$ and inactive in $mr_2$, because of the capacity limit, there is no more space for inactive tasks to stack in, so no matter how long the resource will wait, $t_{i1}$ and $t_i2$ will not be processed and will they will block the other tasks from being processed.

The method to solve the job-lock problem is to add the status changed task to the predecessor set of all the other tasks in the same inactive queue list.
% subsection tricky_problems (end)
% section design_of_the_ecosystem (end)
